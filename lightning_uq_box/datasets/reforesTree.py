"""ReforesTree Dataset."""

import os
from typing import Union

import kornia.augmentation as K
import matplotlib.pyplot as plt
import seaborn as sns
import torch
from torch import Tensor
from torchgeo.datasets import ReforesTree
from torchgeo.samplers.utils import _to_tuple

# TODO
# 1. split 4000x4000 patches and deal with all white area
# 2. come up with a reasonable and motivated OOD split
#     - across sites
#     - across agb value ranges
# 3. Should come up with a fixed dataset version for reproducibility (CC-BY-4.0 allows a redistribution of our dataset)
# 4. There are some caveats about this dataset (bounding boxes generated by algorithm, area really all trees within area measured?). Nevertheless, still the best dataset available for this task


class ReforesTreeRegression(ReforesTree):
    """ReforesTree Dataset focusing on Regresion Task.

    Wrapper around TorchGeo implementation.
    """

    valid_splits = ["train", "test"]

    sites = {
        "train": [
            "Nestor Macias RGB",
            "Flora Pluas RGB",
            "Leonor Aspiazu RGB",
            "Carlos Vera Arteaga RGB",
        ],
        "test": ["Carlos Vera Guevara RGB", "Manuel Macias RGB"],
    }

    def __init__(
        self,
        root: str = "data",
        download: bool = False,
        checksum: bool = False,
        split: str = "train",
        img_size: Union[int, tuple[int]] = 224,
        crop_size: Union[int, tuple[int]] = 1024,
    ) -> None:
        """Initialize a new instance of Dataset.

        Args:
            root: dataset root
            transforms: transformations passed to the dataset
            download: whether or not to download the dataset
            checksum: whether or not to checksum dataset
            split: which dataset split to retrieve
        """
        super().__init__(root, None, download, checksum)

        assert split in self.valid_splits
        self.split = split

        # site_df = self.annot_df.groupby("img_path")["AGB"].sum().reset_index()
        # site_df = pd.merge(
        #     site_df, self.annot_df[["img_path", "img_name"]], on="img_path", how="left"
        # )
        # fig = self.create_summary_statistics(site_df)

        # plt.show()
        import pdb

        pdb.set_trace()

        self.annot_df = self.annot_df[self.annot_df["site"].isin(self.sites[split])]
        # adjust files based on the train or test annot_df
        self.files = [
            path
            for path in self.files
            if path.split("/")[-1] in self.annot_df["img_path"].unique()
        ]

        self.img_size = img_size

        self.random_crop = K.RandomCrop(size=_to_tuple(crop_size), p=1.0)
        self.resize = K.Resize(size=_to_tuple(img_size), p=1.0)

        # another idea would be to overwrite self.files with a precomputed number of samples over which
        # we can also compute normalization statistics

    def create_summary_statistics(self, df) -> plt.Figure:
        """Create summary statistics for annotations."""
        fig, axs = plt.subplots(1, 3)
        df.sort_values(by="img_name", inplace=True)

        df["img_name"].value_counts().plot(kind="bar", ax=axs[0])
        axs[0].tick_params(axis="x", labelrotation=60)
        axs[0].set_title("Number of images per site.")
        axs[0].set_xlabel("Site name")
        axs[0].set_ylabel("Number of images for this site")

        axs[1].violinplot(df["AGB"])
        axs[1].set_title("Distribution of AGB across all tiles.")
        axs[1].set_xlabel("AGB")

        # df = df[df["AGB"] < 100].sort_values(by="img_name")
        axs[2] = sns.violinplot(data=df, x="img_name", y="AGB")
        axs[2].tick_params(axis="x", labelrotation=60)
        axs[2].set_title("Distribution of AGB for each site.")
        axs[2].set_xlabel("AGB")

        plt.tight_layout()

        return fig

    def _load_target(self, filepath: str, bounds: tuple[float]) -> Tensor:
        """Load boxes and labels for a single image.

        Args:
            filepath: image tile filepath
            bounds: random cropped bounds []

        Returns:
            Tensor containing agb value for this patch
        """
        tile_df = self.annot_df[self.annot_df["img_path"] == os.path.basename(filepath)]

        x_min, x_max, y_min, y_max = bounds

        # filter based on bounds
        tile_df = tile_df[
            (tile_df["xmin"] >= x_min)
            & (tile_df["xmax"] <= x_max)
            & (tile_df["ymin"] >= y_min)
            & (tile_df["ymax"] <= y_max)
        ]
        # cumulative AGB for patch
        agb = torch.Tensor([tile_df["AGB"].sum()])

        return agb

    def __getitem__(self, index: int) -> dict[str, Tensor]:
        """Return a sample from the dataset.

        Args:
            index: sample index to return

        Returns:
            data and label at that index
        """
        filepath = self.files[index]

        image = self._load_image(filepath)

        # normalize image
        image = image / 255.0

        # random patch
        image = self.random_crop(image)
        params = self.random_crop._params["src"].squeeze(0)

        x_min, x_max, y_min, y_max = (
            params[:, 0].min().item(),
            params[:, 0].max().item(),
            params[:, 1].min().item(),
            params[:, 1].max().item(),
        )

        # resize image to desired img_size
        image = self.resize(image).squeeze(0)

        # get target
        agb = self._load_target(filepath, (x_min, x_max, y_min, y_max))

        return {"image": image, "target": agb}


ds = ReforesTreeRegression(
    root="/home/nils/projects/uq-method-box/experiments/data/reforesTree"
)

fig, axs = plt.subplots(ncols=3)

idx = 0
for i in range(len(ds)):
    sample = ds[i]
    print(sample["target"])
    if sample["target"] > 30 and idx < 3:
        axs[idx].imshow(sample["image"].permute(1, 2, 0).numpy())
        axs[idx].set_title(f"AGB of {sample['target'].item():.2f}")
        axs[idx].axis("off")
        # plt.savefig(f"sample_{i}.png")
        idx += 1

    if idx >= 3:
        import pdb

        pdb.set_trace()
        plt.show()


import pdb

pdb.set_trace()

print(0)
